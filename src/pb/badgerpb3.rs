// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `src/pb/badgerpb3.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:badgerpb3.KV)
pub struct KV {
    // message fields
    // @@protoc_insertion_point(field:badgerpb3.KV.key)
    pub key: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:badgerpb3.KV.value)
    pub value: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:badgerpb3.KV.user_meta)
    pub user_meta: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:badgerpb3.KV.version)
    pub version: u64,
    // @@protoc_insertion_point(field:badgerpb3.KV.expires_at)
    pub expires_at: u64,
    // @@protoc_insertion_point(field:badgerpb3.KV.meta)
    pub meta: ::std::vec::Vec<u8>,
    ///  Stream id is used to identify which stream the KV came from.
    // @@protoc_insertion_point(field:badgerpb3.KV.stream_id)
    pub stream_id: u32,
    ///  Stream done is used to indicate end of stream.
    // @@protoc_insertion_point(field:badgerpb3.KV.stream_done)
    pub stream_done: bool,
    // @@protoc_insertion_point(field:badgerpb3.KV.kind)
    pub kind: ::protobuf::EnumOrUnknown<kv::Kind>,
    // special fields
    // @@protoc_insertion_point(special_field:badgerpb3.KV.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KV {
    fn default() -> &'a KV {
        <KV as ::protobuf::Message>::default_instance()
    }
}

impl KV {
    pub fn new() -> KV {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &KV| { &m.key },
            |m: &mut KV| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &KV| { &m.value },
            |m: &mut KV| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_meta",
            |m: &KV| { &m.user_meta },
            |m: &mut KV| { &mut m.user_meta },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &KV| { &m.version },
            |m: &mut KV| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "expires_at",
            |m: &KV| { &m.expires_at },
            |m: &mut KV| { &mut m.expires_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "meta",
            |m: &KV| { &m.meta },
            |m: &mut KV| { &mut m.meta },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stream_id",
            |m: &KV| { &m.stream_id },
            |m: &mut KV| { &mut m.stream_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stream_done",
            |m: &KV| { &m.stream_done },
            |m: &mut KV| { &mut m.stream_done },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "kind",
            |m: &KV| { &m.kind },
            |m: &mut KV| { &mut m.kind },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KV>(
            "KV",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KV {
    const NAME: &'static str = "KV";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = is.read_bytes()?;
                },
                18 => {
                    self.value = is.read_bytes()?;
                },
                26 => {
                    self.user_meta = is.read_bytes()?;
                },
                32 => {
                    self.version = is.read_uint64()?;
                },
                40 => {
                    self.expires_at = is.read_uint64()?;
                },
                50 => {
                    self.meta = is.read_bytes()?;
                },
                80 => {
                    self.stream_id = is.read_uint32()?;
                },
                88 => {
                    self.stream_done = is.read_bool()?;
                },
                96 => {
                    self.kind = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        if !self.user_meta.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.user_meta);
        }
        if self.version != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.version);
        }
        if self.expires_at != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.expires_at);
        }
        if !self.meta.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.meta);
        }
        if self.stream_id != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.stream_id);
        }
        if self.stream_done != false {
            my_size += 1 + 1;
        }
        if self.kind != ::protobuf::EnumOrUnknown::new(kv::Kind::KEY) {
            my_size += ::protobuf::rt::int32_size(12, self.kind.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        if !self.user_meta.is_empty() {
            os.write_bytes(3, &self.user_meta)?;
        }
        if self.version != 0 {
            os.write_uint64(4, self.version)?;
        }
        if self.expires_at != 0 {
            os.write_uint64(5, self.expires_at)?;
        }
        if !self.meta.is_empty() {
            os.write_bytes(6, &self.meta)?;
        }
        if self.stream_id != 0 {
            os.write_uint32(10, self.stream_id)?;
        }
        if self.stream_done != false {
            os.write_bool(11, self.stream_done)?;
        }
        if self.kind != ::protobuf::EnumOrUnknown::new(kv::Kind::KEY) {
            os.write_enum(12, ::protobuf::EnumOrUnknown::value(&self.kind))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KV {
        KV::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.user_meta.clear();
        self.version = 0;
        self.expires_at = 0;
        self.meta.clear();
        self.stream_id = 0;
        self.stream_done = false;
        self.kind = ::protobuf::EnumOrUnknown::new(kv::Kind::KEY);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KV {
        static instance: KV = KV {
            key: ::std::vec::Vec::new(),
            value: ::std::vec::Vec::new(),
            user_meta: ::std::vec::Vec::new(),
            version: 0,
            expires_at: 0,
            meta: ::std::vec::Vec::new(),
            stream_id: 0,
            stream_done: false,
            kind: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KV {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KV").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KV {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KV {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `KV`
pub mod kv {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:badgerpb3.KV.Kind)
    pub enum Kind {
        // @@protoc_insertion_point(enum_value:badgerpb3.KV.Kind.KEY)
        KEY = 0,
        // @@protoc_insertion_point(enum_value:badgerpb3.KV.Kind.DATA_KEY)
        DATA_KEY = 1,
        // @@protoc_insertion_point(enum_value:badgerpb3.KV.Kind.FILE)
        FILE = 2,
    }

    impl ::protobuf::Enum for Kind {
        const NAME: &'static str = "Kind";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Kind> {
            match value {
                0 => ::std::option::Option::Some(Kind::KEY),
                1 => ::std::option::Option::Some(Kind::DATA_KEY),
                2 => ::std::option::Option::Some(Kind::FILE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Kind] = &[
            Kind::KEY,
            Kind::DATA_KEY,
            Kind::FILE,
        ];
    }

    impl ::protobuf::EnumFull for Kind {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("KV.Kind").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Kind {
        fn default() -> Self {
            Kind::KEY
        }
    }

    impl Kind {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Kind>("KV.Kind")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:badgerpb3.KVList)
pub struct KVList {
    // message fields
    // @@protoc_insertion_point(field:badgerpb3.KVList.kv)
    pub kv: ::std::vec::Vec<KV>,
    ///  alloc_ref used internally for memory management.
    // @@protoc_insertion_point(field:badgerpb3.KVList.alloc_ref)
    pub alloc_ref: u64,
    // special fields
    // @@protoc_insertion_point(special_field:badgerpb3.KVList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KVList {
    fn default() -> &'a KVList {
        <KVList as ::protobuf::Message>::default_instance()
    }
}

impl KVList {
    pub fn new() -> KVList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "kv",
            |m: &KVList| { &m.kv },
            |m: &mut KVList| { &mut m.kv },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "alloc_ref",
            |m: &KVList| { &m.alloc_ref },
            |m: &mut KVList| { &mut m.alloc_ref },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KVList>(
            "KVList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KVList {
    const NAME: &'static str = "KVList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.kv.push(is.read_message()?);
                },
                80 => {
                    self.alloc_ref = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.kv {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.alloc_ref != 0 {
            my_size += ::protobuf::rt::uint64_size(10, self.alloc_ref);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.kv {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.alloc_ref != 0 {
            os.write_uint64(10, self.alloc_ref)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KVList {
        KVList::new()
    }

    fn clear(&mut self) {
        self.kv.clear();
        self.alloc_ref = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KVList {
        static instance: KVList = KVList {
            kv: ::std::vec::Vec::new(),
            alloc_ref: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KVList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KVList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KVList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KVList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:badgerpb3.ManifestChangeSet)
pub struct ManifestChangeSet {
    // message fields
    ///  A set of changes that are applied atomically.
    // @@protoc_insertion_point(field:badgerpb3.ManifestChangeSet.changes)
    pub changes: ::std::vec::Vec<ManifestChange>,
    // special fields
    // @@protoc_insertion_point(special_field:badgerpb3.ManifestChangeSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ManifestChangeSet {
    fn default() -> &'a ManifestChangeSet {
        <ManifestChangeSet as ::protobuf::Message>::default_instance()
    }
}

impl ManifestChangeSet {
    pub fn new() -> ManifestChangeSet {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "changes",
            |m: &ManifestChangeSet| { &m.changes },
            |m: &mut ManifestChangeSet| { &mut m.changes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ManifestChangeSet>(
            "ManifestChangeSet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ManifestChangeSet {
    const NAME: &'static str = "ManifestChangeSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.changes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.changes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.changes {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ManifestChangeSet {
        ManifestChangeSet::new()
    }

    fn clear(&mut self) {
        self.changes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ManifestChangeSet {
        static instance: ManifestChangeSet = ManifestChangeSet {
            changes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ManifestChangeSet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ManifestChangeSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ManifestChangeSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ManifestChangeSet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:badgerpb3.ManifestChange)
pub struct ManifestChange {
    // message fields
    // @@protoc_insertion_point(field:badgerpb3.ManifestChange.Id)
    pub Id: u64,
    // @@protoc_insertion_point(field:badgerpb3.ManifestChange.Op)
    pub Op: ::protobuf::EnumOrUnknown<manifest_change::Operation>,
    // @@protoc_insertion_point(field:badgerpb3.ManifestChange.Level)
    pub Level: u32,
    // @@protoc_insertion_point(field:badgerpb3.ManifestChange.key_id)
    pub key_id: u64,
    // @@protoc_insertion_point(field:badgerpb3.ManifestChange.encryption_algo)
    pub encryption_algo: ::protobuf::EnumOrUnknown<EncryptionAlgo>,
    // @@protoc_insertion_point(field:badgerpb3.ManifestChange.compression)
    pub compression: u32,
    // special fields
    // @@protoc_insertion_point(special_field:badgerpb3.ManifestChange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ManifestChange {
    fn default() -> &'a ManifestChange {
        <ManifestChange as ::protobuf::Message>::default_instance()
    }
}

impl ManifestChange {
    pub fn new() -> ManifestChange {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Id",
            |m: &ManifestChange| { &m.Id },
            |m: &mut ManifestChange| { &mut m.Id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Op",
            |m: &ManifestChange| { &m.Op },
            |m: &mut ManifestChange| { &mut m.Op },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Level",
            |m: &ManifestChange| { &m.Level },
            |m: &mut ManifestChange| { &mut m.Level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key_id",
            |m: &ManifestChange| { &m.key_id },
            |m: &mut ManifestChange| { &mut m.key_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "encryption_algo",
            |m: &ManifestChange| { &m.encryption_algo },
            |m: &mut ManifestChange| { &mut m.encryption_algo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "compression",
            |m: &ManifestChange| { &m.compression },
            |m: &mut ManifestChange| { &mut m.compression },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ManifestChange>(
            "ManifestChange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ManifestChange {
    const NAME: &'static str = "ManifestChange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.Id = is.read_uint64()?;
                },
                16 => {
                    self.Op = is.read_enum_or_unknown()?;
                },
                24 => {
                    self.Level = is.read_uint32()?;
                },
                32 => {
                    self.key_id = is.read_uint64()?;
                },
                40 => {
                    self.encryption_algo = is.read_enum_or_unknown()?;
                },
                48 => {
                    self.compression = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.Id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.Id);
        }
        if self.Op != ::protobuf::EnumOrUnknown::new(manifest_change::Operation::CREATE) {
            my_size += ::protobuf::rt::int32_size(2, self.Op.value());
        }
        if self.Level != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.Level);
        }
        if self.key_id != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.key_id);
        }
        if self.encryption_algo != ::protobuf::EnumOrUnknown::new(EncryptionAlgo::aes) {
            my_size += ::protobuf::rt::int32_size(5, self.encryption_algo.value());
        }
        if self.compression != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.compression);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.Id != 0 {
            os.write_uint64(1, self.Id)?;
        }
        if self.Op != ::protobuf::EnumOrUnknown::new(manifest_change::Operation::CREATE) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.Op))?;
        }
        if self.Level != 0 {
            os.write_uint32(3, self.Level)?;
        }
        if self.key_id != 0 {
            os.write_uint64(4, self.key_id)?;
        }
        if self.encryption_algo != ::protobuf::EnumOrUnknown::new(EncryptionAlgo::aes) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.encryption_algo))?;
        }
        if self.compression != 0 {
            os.write_uint32(6, self.compression)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ManifestChange {
        ManifestChange::new()
    }

    fn clear(&mut self) {
        self.Id = 0;
        self.Op = ::protobuf::EnumOrUnknown::new(manifest_change::Operation::CREATE);
        self.Level = 0;
        self.key_id = 0;
        self.encryption_algo = ::protobuf::EnumOrUnknown::new(EncryptionAlgo::aes);
        self.compression = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ManifestChange {
        static instance: ManifestChange = ManifestChange {
            Id: 0,
            Op: ::protobuf::EnumOrUnknown::from_i32(0),
            Level: 0,
            key_id: 0,
            encryption_algo: ::protobuf::EnumOrUnknown::from_i32(0),
            compression: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ManifestChange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ManifestChange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ManifestChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ManifestChange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ManifestChange`
pub mod manifest_change {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:badgerpb3.ManifestChange.Operation)
    pub enum Operation {
        // @@protoc_insertion_point(enum_value:badgerpb3.ManifestChange.Operation.CREATE)
        CREATE = 0,
        // @@protoc_insertion_point(enum_value:badgerpb3.ManifestChange.Operation.DELETE)
        DELETE = 1,
    }

    impl ::protobuf::Enum for Operation {
        const NAME: &'static str = "Operation";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Operation> {
            match value {
                0 => ::std::option::Option::Some(Operation::CREATE),
                1 => ::std::option::Option::Some(Operation::DELETE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Operation] = &[
            Operation::CREATE,
            Operation::DELETE,
        ];
    }

    impl ::protobuf::EnumFull for Operation {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ManifestChange.Operation").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Operation {
        fn default() -> Self {
            Operation::CREATE
        }
    }

    impl Operation {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Operation>("ManifestChange.Operation")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:badgerpb3.Checksum)
pub struct Checksum {
    // message fields
    // @@protoc_insertion_point(field:badgerpb3.Checksum.algo)
    pub algo: ::protobuf::EnumOrUnknown<checksum::Algorithm>,
    // @@protoc_insertion_point(field:badgerpb3.Checksum.sum)
    pub sum: u64,
    // special fields
    // @@protoc_insertion_point(special_field:badgerpb3.Checksum.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Checksum {
    fn default() -> &'a Checksum {
        <Checksum as ::protobuf::Message>::default_instance()
    }
}

impl Checksum {
    pub fn new() -> Checksum {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "algo",
            |m: &Checksum| { &m.algo },
            |m: &mut Checksum| { &mut m.algo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sum",
            |m: &Checksum| { &m.sum },
            |m: &mut Checksum| { &mut m.sum },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Checksum>(
            "Checksum",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Checksum {
    const NAME: &'static str = "Checksum";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.algo = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.sum = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.algo != ::protobuf::EnumOrUnknown::new(checksum::Algorithm::CRC32C) {
            my_size += ::protobuf::rt::int32_size(1, self.algo.value());
        }
        if self.sum != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.sum);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.algo != ::protobuf::EnumOrUnknown::new(checksum::Algorithm::CRC32C) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.algo))?;
        }
        if self.sum != 0 {
            os.write_uint64(2, self.sum)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Checksum {
        Checksum::new()
    }

    fn clear(&mut self) {
        self.algo = ::protobuf::EnumOrUnknown::new(checksum::Algorithm::CRC32C);
        self.sum = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Checksum {
        static instance: Checksum = Checksum {
            algo: ::protobuf::EnumOrUnknown::from_i32(0),
            sum: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Checksum {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Checksum").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Checksum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Checksum {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Checksum`
pub mod checksum {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:badgerpb3.Checksum.Algorithm)
    pub enum Algorithm {
        // @@protoc_insertion_point(enum_value:badgerpb3.Checksum.Algorithm.CRC32C)
        CRC32C = 0,
        // @@protoc_insertion_point(enum_value:badgerpb3.Checksum.Algorithm.XXHash64)
        XXHash64 = 1,
    }

    impl ::protobuf::Enum for Algorithm {
        const NAME: &'static str = "Algorithm";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Algorithm> {
            match value {
                0 => ::std::option::Option::Some(Algorithm::CRC32C),
                1 => ::std::option::Option::Some(Algorithm::XXHash64),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Algorithm] = &[
            Algorithm::CRC32C,
            Algorithm::XXHash64,
        ];
    }

    impl ::protobuf::EnumFull for Algorithm {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Checksum.Algorithm").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Algorithm {
        fn default() -> Self {
            Algorithm::CRC32C
        }
    }

    impl Algorithm {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Algorithm>("Checksum.Algorithm")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:badgerpb3.DataKey)
pub struct DataKey {
    // message fields
    // @@protoc_insertion_point(field:badgerpb3.DataKey.key_id)
    pub key_id: u64,
    // @@protoc_insertion_point(field:badgerpb3.DataKey.data)
    pub data: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:badgerpb3.DataKey.iv)
    pub iv: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:badgerpb3.DataKey.created_at)
    pub created_at: i64,
    // special fields
    // @@protoc_insertion_point(special_field:badgerpb3.DataKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DataKey {
    fn default() -> &'a DataKey {
        <DataKey as ::protobuf::Message>::default_instance()
    }
}

impl DataKey {
    pub fn new() -> DataKey {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key_id",
            |m: &DataKey| { &m.key_id },
            |m: &mut DataKey| { &mut m.key_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &DataKey| { &m.data },
            |m: &mut DataKey| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "iv",
            |m: &DataKey| { &m.iv },
            |m: &mut DataKey| { &mut m.iv },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "created_at",
            |m: &DataKey| { &m.created_at },
            |m: &mut DataKey| { &mut m.created_at },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DataKey>(
            "DataKey",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DataKey {
    const NAME: &'static str = "DataKey";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.key_id = is.read_uint64()?;
                },
                18 => {
                    self.data = is.read_bytes()?;
                },
                26 => {
                    self.iv = is.read_bytes()?;
                },
                32 => {
                    self.created_at = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.key_id);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        if !self.iv.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.iv);
        }
        if self.created_at != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.created_at);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key_id != 0 {
            os.write_uint64(1, self.key_id)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        if !self.iv.is_empty() {
            os.write_bytes(3, &self.iv)?;
        }
        if self.created_at != 0 {
            os.write_int64(4, self.created_at)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DataKey {
        DataKey::new()
    }

    fn clear(&mut self) {
        self.key_id = 0;
        self.data.clear();
        self.iv.clear();
        self.created_at = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DataKey {
        static instance: DataKey = DataKey {
            key_id: 0,
            data: ::std::vec::Vec::new(),
            iv: ::std::vec::Vec::new(),
            created_at: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DataKey {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DataKey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DataKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataKey {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:badgerpb3.Match)
pub struct Match {
    // message fields
    // @@protoc_insertion_point(field:badgerpb3.Match.prefix)
    pub prefix: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:badgerpb3.Match.ignore_bytes)
    pub ignore_bytes: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:badgerpb3.Match.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Match {
    fn default() -> &'a Match {
        <Match as ::protobuf::Message>::default_instance()
    }
}

impl Match {
    pub fn new() -> Match {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "prefix",
            |m: &Match| { &m.prefix },
            |m: &mut Match| { &mut m.prefix },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ignore_bytes",
            |m: &Match| { &m.ignore_bytes },
            |m: &mut Match| { &mut m.ignore_bytes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Match>(
            "Match",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Match {
    const NAME: &'static str = "Match";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.prefix = is.read_bytes()?;
                },
                18 => {
                    self.ignore_bytes = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.prefix.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.prefix);
        }
        if !self.ignore_bytes.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.ignore_bytes);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.prefix.is_empty() {
            os.write_bytes(1, &self.prefix)?;
        }
        if !self.ignore_bytes.is_empty() {
            os.write_string(2, &self.ignore_bytes)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Match {
        Match::new()
    }

    fn clear(&mut self) {
        self.prefix.clear();
        self.ignore_bytes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Match {
        static instance: Match = Match {
            prefix: ::std::vec::Vec::new(),
            ignore_bytes: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Match {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Match").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Match {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Match {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:badgerpb3.EncryptionAlgo)
pub enum EncryptionAlgo {
    // @@protoc_insertion_point(enum_value:badgerpb3.EncryptionAlgo.aes)
    aes = 0,
}

impl ::protobuf::Enum for EncryptionAlgo {
    const NAME: &'static str = "EncryptionAlgo";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EncryptionAlgo> {
        match value {
            0 => ::std::option::Option::Some(EncryptionAlgo::aes),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EncryptionAlgo] = &[
        EncryptionAlgo::aes,
    ];
}

impl ::protobuf::EnumFull for EncryptionAlgo {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EncryptionAlgo").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EncryptionAlgo {
    fn default() -> Self {
        EncryptionAlgo::aes
    }
}

impl EncryptionAlgo {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EncryptionAlgo>("EncryptionAlgo")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x16src/pb/badgerpb3.proto\x12\tbadgerpb3\"\xa5\x02\n\x02KV\x12\x10\n\
    \x03key\x18\x01\x20\x01(\x0cR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \x0cR\x05value\x12\x1b\n\tuser_meta\x18\x03\x20\x01(\x0cR\x08userMeta\
    \x12\x18\n\x07version\x18\x04\x20\x01(\x04R\x07version\x12\x1d\n\nexpire\
    s_at\x18\x05\x20\x01(\x04R\texpiresAt\x12\x12\n\x04meta\x18\x06\x20\x01(\
    \x0cR\x04meta\x12\x1b\n\tstream_id\x18\n\x20\x01(\rR\x08streamId\x12\x1f\
    \n\x0bstream_done\x18\x0b\x20\x01(\x08R\nstreamDone\x12&\n\x04kind\x18\
    \x0c\x20\x01(\x0e2\x12.badgerpb3.KV.KindR\x04kind\"'\n\x04Kind\x12\x07\n\
    \x03KEY\x10\0\x12\x0c\n\x08DATA_KEY\x10\x01\x12\x08\n\x04FILE\x10\x02\"D\
    \n\x06KVList\x12\x1d\n\x02kv\x18\x01\x20\x03(\x0b2\r.badgerpb3.KVR\x02kv\
    \x12\x1b\n\talloc_ref\x18\n\x20\x01(\x04R\x08allocRef\"H\n\x11ManifestCh\
    angeSet\x123\n\x07changes\x18\x01\x20\x03(\x0b2\x19.badgerpb3.ManifestCh\
    angeR\x07changes\"\x8d\x02\n\x0eManifestChange\x12\x0e\n\x02Id\x18\x01\
    \x20\x01(\x04R\x02Id\x123\n\x02Op\x18\x02\x20\x01(\x0e2#.badgerpb3.Manif\
    estChange.OperationR\x02Op\x12\x14\n\x05Level\x18\x03\x20\x01(\rR\x05Lev\
    el\x12\x15\n\x06key_id\x18\x04\x20\x01(\x04R\x05keyId\x12B\n\x0fencrypti\
    on_algo\x18\x05\x20\x01(\x0e2\x19.badgerpb3.EncryptionAlgoR\x0eencryptio\
    nAlgo\x12\x20\n\x0bcompression\x18\x06\x20\x01(\rR\x0bcompression\"#\n\t\
    Operation\x12\n\n\x06CREATE\x10\0\x12\n\n\x06DELETE\x10\x01\"v\n\x08Chec\
    ksum\x121\n\x04algo\x18\x01\x20\x01(\x0e2\x1d.badgerpb3.Checksum.Algorit\
    hmR\x04algo\x12\x10\n\x03sum\x18\x02\x20\x01(\x04R\x03sum\"%\n\tAlgorith\
    m\x12\n\n\x06CRC32C\x10\0\x12\x0c\n\x08XXHash64\x10\x01\"c\n\x07DataKey\
    \x12\x15\n\x06key_id\x18\x01\x20\x01(\x04R\x05keyId\x12\x12\n\x04data\
    \x18\x02\x20\x01(\x0cR\x04data\x12\x0e\n\x02iv\x18\x03\x20\x01(\x0cR\x02\
    iv\x12\x1d\n\ncreated_at\x18\x04\x20\x01(\x03R\tcreatedAt\"B\n\x05Match\
    \x12\x16\n\x06prefix\x18\x01\x20\x01(\x0cR\x06prefix\x12!\n\x0cignore_by\
    tes\x18\x02\x20\x01(\tR\x0bignoreBytes*\x19\n\x0eEncryptionAlgo\x12\x07\
    \n\x03aes\x10\0B#Z!github.com/dgraph-io/badger/v3/pbJ\x8b\x19\n\x06\x12\
    \x04\x11\0\\\x01\n\x96\x05\n\x01\x0c\x12\x03\x11\0\x12\x1a.\x20Use\x20pr\
    otos/gen.sh\x20to\x20generate\x20.pb.go\x20files.\r\n2\xdb\x04\r\n\x20Co\
    pyright\x20(C)\x202017\x20Dgraph\x20Labs,\x20Inc.\x20and\x20Contributors\
    \r\n\r\n\x20Licensed\x20under\x20the\x20Apache\x20License,\x20Version\
    \x202.0\x20(the\x20\"License\");\r\n\x20you\x20may\x20not\x20use\x20this\
    \x20file\x20except\x20in\x20compliance\x20with\x20the\x20License.\r\n\
    \x20You\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20License\x20at\r\n\
    \r\n\x20\x20\x20\x20http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n\
    \x20Unless\x20required\x20by\x20applicable\x20law\x20or\x20agreed\x20to\
    \x20in\x20writing,\x20software\r\n\x20distributed\x20under\x20the\x20Lic\
    ense\x20is\x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\r\n\x20W\
    ITHOUT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\
    \x20express\x20or\x20implied.\r\n\x20See\x20the\x20License\x20for\x20the\
    \x20specific\x20language\x20governing\x20permissions\x20and\r\n\x20limit\
    ations\x20under\x20the\x20License.\r\n\n\x08\n\x01\x02\x12\x03\x13\0\x12\
    \n\x08\n\x01\x08\x12\x03\x15\08\n\t\n\x02\x08\x0b\x12\x03\x15\08\n\n\n\
    \x02\x04\0\x12\x04\x17\0*\x01\n\n\n\x03\x04\0\x01\x12\x03\x17\x08\n\n\
    \x0b\n\x04\x04\0\x02\0\x12\x03\x18\x02\x10\n\x0c\n\x05\x04\0\x02\0\x05\
    \x12\x03\x18\x02\x07\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x18\x08\x0b\n\
    \x0c\n\x05\x04\0\x02\0\x03\x12\x03\x18\x0e\x0f\n\x0b\n\x04\x04\0\x02\x01\
    \x12\x03\x19\x02\x12\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\x19\x02\x07\n\
    \x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x19\x08\r\n\x0c\n\x05\x04\0\x02\x01\
    \x03\x12\x03\x19\x10\x11\n\x0b\n\x04\x04\0\x02\x02\x12\x03\x1a\x02\x16\n\
    \x0c\n\x05\x04\0\x02\x02\x05\x12\x03\x1a\x02\x07\n\x0c\n\x05\x04\0\x02\
    \x02\x01\x12\x03\x1a\x08\x11\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\x1a\
    \x14\x15\n\x0b\n\x04\x04\0\x02\x03\x12\x03\x1b\x02\x15\n\x0c\n\x05\x04\0\
    \x02\x03\x05\x12\x03\x1b\x02\x08\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03\
    \x1b\t\x10\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03\x1b\x13\x14\n\x0b\n\x04\
    \x04\0\x02\x04\x12\x03\x1c\x02\x18\n\x0c\n\x05\x04\0\x02\x04\x05\x12\x03\
    \x1c\x02\x08\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03\x1c\t\x13\n\x0c\n\x05\
    \x04\0\x02\x04\x03\x12\x03\x1c\x16\x17\n\x0b\n\x04\x04\0\x02\x05\x12\x03\
    \x1d\x02\x11\n\x0c\n\x05\x04\0\x02\x05\x05\x12\x03\x1d\x02\x07\n\x0c\n\
    \x05\x04\0\x02\x05\x01\x12\x03\x1d\x08\x0c\n\x0c\n\x05\x04\0\x02\x05\x03\
    \x12\x03\x1d\x0f\x10\nL\n\x04\x04\0\x02\x06\x12\x03\x20\x02\x18\x1a?\x20\
    Stream\x20id\x20is\x20used\x20to\x20identify\x20which\x20stream\x20the\
    \x20KV\x20came\x20from.\r\n\n\x0c\n\x05\x04\0\x02\x06\x05\x12\x03\x20\
    \x02\x08\n\x0c\n\x05\x04\0\x02\x06\x01\x12\x03\x20\t\x12\n\x0c\n\x05\x04\
    \0\x02\x06\x03\x12\x03\x20\x15\x17\n>\n\x04\x04\0\x02\x07\x12\x03\"\x02\
    \x18\x1a1\x20Stream\x20done\x20is\x20used\x20to\x20indicate\x20end\x20of\
    \x20stream.\r\n\n\x0c\n\x05\x04\0\x02\x07\x05\x12\x03\"\x02\x06\n\x0c\n\
    \x05\x04\0\x02\x07\x01\x12\x03\"\x07\x12\n\x0c\n\x05\x04\0\x02\x07\x03\
    \x12\x03\"\x15\x17\n\x0c\n\x04\x04\0\x04\0\x12\x04$\x02(\x03\n\x0c\n\x05\
    \x04\0\x04\0\x01\x12\x03$\x07\x0b\n\r\n\x06\x04\0\x04\0\x02\0\x12\x03%\
    \x04\x0c\n\x0e\n\x07\x04\0\x04\0\x02\0\x01\x12\x03%\x04\x07\n\x0e\n\x07\
    \x04\0\x04\0\x02\0\x02\x12\x03%\n\x0b\n\r\n\x06\x04\0\x04\0\x02\x01\x12\
    \x03&\x04\x11\n\x0e\n\x07\x04\0\x04\0\x02\x01\x01\x12\x03&\x04\x0c\n\x0e\
    \n\x07\x04\0\x04\0\x02\x01\x02\x12\x03&\x0f\x10\n\r\n\x06\x04\0\x04\0\
    \x02\x02\x12\x03'\x04\r\n\x0e\n\x07\x04\0\x04\0\x02\x02\x01\x12\x03'\x04\
    \x08\n\x0e\n\x07\x04\0\x04\0\x02\x02\x02\x12\x03'\x0b\x0c\n\x0b\n\x04\
    \x04\0\x02\x08\x12\x03)\x02\x11\n\x0c\n\x05\x04\0\x02\x08\x06\x12\x03)\
    \x02\x06\n\x0c\n\x05\x04\0\x02\x08\x01\x12\x03)\x07\x0b\n\x0c\n\x05\x04\
    \0\x02\x08\x03\x12\x03)\x0e\x10\n\n\n\x02\x04\x01\x12\x04,\01\x01\n\n\n\
    \x03\x04\x01\x01\x12\x03,\x08\x0e\n\x0b\n\x04\x04\x01\x02\0\x12\x03-\x02\
    \x15\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03-\x02\n\n\x0c\n\x05\x04\x01\
    \x02\0\x06\x12\x03-\x0b\r\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03-\x0e\x10\
    \n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03-\x13\x14\n@\n\x04\x04\x01\x02\x01\
    \x12\x030\x02\x18\x1a3\x20alloc_ref\x20used\x20internally\x20for\x20memo\
    ry\x20management.\r\n\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x030\x02\x08\n\
    \x0c\n\x05\x04\x01\x02\x01\x01\x12\x030\t\x12\n\x0c\n\x05\x04\x01\x02\
    \x01\x03\x12\x030\x15\x17\n\n\n\x02\x04\x02\x12\x043\06\x01\n\n\n\x03\
    \x04\x02\x01\x12\x033\x08\x19\n=\n\x04\x04\x02\x02\0\x12\x035\x02&\x1a0\
    \x20A\x20set\x20of\x20changes\x20that\x20are\x20applied\x20atomically.\r\
    \n\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x035\x02\n\n\x0c\n\x05\x04\x02\x02\
    \0\x06\x12\x035\x0b\x19\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x035\x1a!\n\
    \x0c\n\x05\x04\x02\x02\0\x03\x12\x035$%\n\n\n\x02\x05\0\x12\x048\0:\x01\
    \n\n\n\x03\x05\0\x01\x12\x038\x05\x13\n\x0b\n\x04\x05\0\x02\0\x12\x039\
    \x02\n\n\x0c\n\x05\x05\0\x02\0\x01\x12\x039\x02\x05\n\x0c\n\x05\x05\0\
    \x02\0\x02\x12\x039\x08\t\n\n\n\x02\x04\x03\x12\x04<\0G\x01\n\n\n\x03\
    \x04\x03\x01\x12\x03<\x08\x16\n\x19\n\x04\x04\x03\x02\0\x12\x03=\x02\x10\
    \"\x0c\x20Table\x20ID.\r\n\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03=\x02\
    \x08\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03=\t\x0b\n\x0c\n\x05\x04\x03\
    \x02\0\x03\x12\x03=\x0e\x0f\n\x0c\n\x04\x04\x03\x04\0\x12\x04>\x02A\x03\
    \n\x0c\n\x05\x04\x03\x04\0\x01\x12\x03>\x07\x10\n\r\n\x06\x04\x03\x04\0\
    \x02\0\x12\x03?\x04\x0f\n\x0e\n\x07\x04\x03\x04\0\x02\0\x01\x12\x03?\x04\
    \n\n\x0e\n\x07\x04\x03\x04\0\x02\0\x02\x12\x03?\r\x0e\n\r\n\x06\x04\x03\
    \x04\0\x02\x01\x12\x03@\x04\x0f\n\x0e\n\x07\x04\x03\x04\0\x02\x01\x01\
    \x12\x03@\x04\n\n\x0e\n\x07\x04\x03\x04\0\x02\x01\x02\x12\x03@\r\x0e\n\
    \x0b\n\x04\x04\x03\x02\x01\x12\x03B\x02\x15\n\x0c\n\x05\x04\x03\x02\x01\
    \x06\x12\x03B\x02\x0b\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03B\x0c\x0e\n\
    \x0c\n\x05\x04\x03\x02\x01\x03\x12\x03B\x13\x14\n%\n\x04\x04\x03\x02\x02\
    \x12\x03C\x02\x15\"\x18\x20Only\x20used\x20for\x20CREATE.\r\n\n\x0c\n\
    \x05\x04\x03\x02\x02\x05\x12\x03C\x02\x08\n\x0c\n\x05\x04\x03\x02\x02\
    \x01\x12\x03C\t\x0e\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x03C\x13\x14\n\
    \x0b\n\x04\x04\x03\x02\x03\x12\x03D\x02\x15\n\x0c\n\x05\x04\x03\x02\x03\
    \x05\x12\x03D\x02\x08\n\x0c\n\x05\x04\x03\x02\x03\x01\x12\x03D\t\x0f\n\
    \x0c\n\x05\x04\x03\x02\x03\x03\x12\x03D\x13\x14\n\x0b\n\x04\x04\x03\x02\
    \x04\x12\x03E\x02%\n\x0c\n\x05\x04\x03\x02\x04\x06\x12\x03E\x02\x10\n\
    \x0c\n\x05\x04\x03\x02\x04\x01\x12\x03E\x11\x20\n\x0c\n\x05\x04\x03\x02\
    \x04\x03\x12\x03E#$\n(\n\x04\x04\x03\x02\x05\x12\x03F\x02\x19\"\x1b\x20O\
    nly\x20used\x20for\x20CREATE\x20Op.\r\n\n\x0c\n\x05\x04\x03\x02\x05\x05\
    \x12\x03F\x02\x08\n\x0c\n\x05\x04\x03\x02\x05\x01\x12\x03F\t\x14\n\x0c\n\
    \x05\x04\x03\x02\x05\x03\x12\x03F\x17\x18\n\n\n\x02\x04\x04\x12\x04I\0P\
    \x01\n\n\n\x03\x04\x04\x01\x12\x03I\x08\x10\n\x0c\n\x04\x04\x04\x04\0\
    \x12\x04J\x02M\x03\n\x0c\n\x05\x04\x04\x04\0\x01\x12\x03J\x07\x10\n\r\n\
    \x06\x04\x04\x04\0\x02\0\x12\x03K\x04\x0f\n\x0e\n\x07\x04\x04\x04\0\x02\
    \0\x01\x12\x03K\x04\n\n\x0e\n\x07\x04\x04\x04\0\x02\0\x02\x12\x03K\r\x0e\
    \n\r\n\x06\x04\x04\x04\0\x02\x01\x12\x03L\x04\x11\n\x0e\n\x07\x04\x04\
    \x04\0\x02\x01\x01\x12\x03L\x04\x0c\n\x0e\n\x07\x04\x04\x04\0\x02\x01\
    \x02\x12\x03L\x0f\x10\n;\n\x04\x04\x04\x02\0\x12\x03N\x02\x15\".\x20For\
    \x20storing\x20type\x20of\x20Checksum\x20algorithm\x20used\r\n\n\x0c\n\
    \x05\x04\x04\x02\0\x06\x12\x03N\x02\x0b\n\x0c\n\x05\x04\x04\x02\0\x01\
    \x12\x03N\x0c\x10\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03N\x13\x14\n\x0b\n\
    \x04\x04\x04\x02\x01\x12\x03O\x02\x11\n\x0c\n\x05\x04\x04\x02\x01\x05\
    \x12\x03O\x02\x08\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03O\t\x0c\n\x0c\n\
    \x05\x04\x04\x02\x01\x03\x12\x03O\x0f\x10\n\n\n\x02\x04\x05\x12\x04R\0W\
    \x01\n\n\n\x03\x04\x05\x01\x12\x03R\x08\x0f\n\x0b\n\x04\x04\x05\x02\0\
    \x12\x03S\x02\x19\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03S\x02\x08\n\x0c\n\
    \x05\x04\x05\x02\0\x01\x12\x03S\t\x0f\n\x0c\n\x05\x04\x05\x02\0\x03\x12\
    \x03S\x17\x18\n\x0b\n\x04\x04\x05\x02\x01\x12\x03T\x02\x18\n\x0c\n\x05\
    \x04\x05\x02\x01\x05\x12\x03T\x02\x07\n\x0c\n\x05\x04\x05\x02\x01\x01\
    \x12\x03T\t\r\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03T\x16\x17\n\x0b\n\
    \x04\x04\x05\x02\x02\x12\x03U\x02\x18\n\x0c\n\x05\x04\x05\x02\x02\x05\
    \x12\x03U\x02\x07\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x03U\t\x0b\n\x0c\n\
    \x05\x04\x05\x02\x02\x03\x12\x03U\x16\x17\n\x0b\n\x04\x04\x05\x02\x03\
    \x12\x03V\x02\x18\n\x0c\n\x05\x04\x05\x02\x03\x05\x12\x03V\x02\x07\n\x0c\
    \n\x05\x04\x05\x02\x03\x01\x12\x03V\t\x13\n\x0c\n\x05\x04\x05\x02\x03\
    \x03\x12\x03V\x16\x17\n\n\n\x02\x04\x06\x12\x04Y\0\\\x01\n\n\n\x03\x04\
    \x06\x01\x12\x03Y\x08\r\n\x0b\n\x04\x04\x06\x02\0\x12\x03Z\x02\x13\n\x0c\
    \n\x05\x04\x06\x02\0\x05\x12\x03Z\x02\x07\n\x0c\n\x05\x04\x06\x02\0\x01\
    \x12\x03Z\x08\x0e\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03Z\x11\x12\nN\n\
    \x04\x04\x06\x02\x01\x12\x03[\x02\x1a\"A\x20Comma\x20separated\x20with\
    \x20dash\x20to\x20represent\x20ranges\x20\"1,\x202-3,\x204-7,\x209\"\r\n\
    \n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03[\x02\x08\n\x0c\n\x05\x04\x06\
    \x02\x01\x01\x12\x03[\t\x15\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03[\x18\
    \x19b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(7);
            messages.push(KV::generated_message_descriptor_data());
            messages.push(KVList::generated_message_descriptor_data());
            messages.push(ManifestChangeSet::generated_message_descriptor_data());
            messages.push(ManifestChange::generated_message_descriptor_data());
            messages.push(Checksum::generated_message_descriptor_data());
            messages.push(DataKey::generated_message_descriptor_data());
            messages.push(Match::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(4);
            enums.push(EncryptionAlgo::generated_enum_descriptor_data());
            enums.push(kv::Kind::generated_enum_descriptor_data());
            enums.push(manifest_change::Operation::generated_enum_descriptor_data());
            enums.push(checksum::Algorithm::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
